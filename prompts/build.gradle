import groovy.io.FileType
import groovy.json.JsonSlurper

repositories {
    ivy {
        url 'http://www.coli.uni-saarland.de/courses/elevator15/audio'
        layout 'pattern', {
            artifact '[module]_[classifier].[ext]'
        }
    }
}

configurations {
    data
}

dependencies {
    data group: 'ellavator', name: 'alexander', classifier: 'close_16', ext: 'flac'
    data group: 'ellavator', name: 'anne', classifier: 'close_16', ext: 'flac'
    data group: 'ellavator', name: 'bryan', classifier: 'close_16', ext: 'flac'
    data group: 'ellavator', name: 'kata', classifier: 'close_16', ext: 'flac'
    data group: 'ellavator', name: 'laura', classifier: 'close_16', ext: 'flac'
    data group: 'ellavator', name: 'pavel', classifier: 'close_16', ext: 'flac'
}

sourceSets {
    text
    data
}

task getAudio(type: Copy) {
    from configurations.data
    into sourceSets.data.output.resourcesDir
    rename ~/\-*close_16/, ''
    processDataResources.dependsOn it
}

task generatePromptList {
    inputs.files processTextResources
    def texFile = file("$sourceSets.text.output.resourcesDir/prompts.tex")
    outputs.files texFile
    doLast {
        texFile.withWriter { tex ->
            tex.println "\\documentclass[aspectratio=169]{beamer}"
            tex.println "\\usepackage[utf8]{inputenc}"
            tex.println "\\beamertemplatenavigationsymbolsempty"
            tex.println "\\setbeamertemplate{footline}[frame number]"
            tex.println "\\newcommand*{\\prompt}[1]{%"
            tex.println "  \\frame{\\Huge\\centering #1}"
            tex.println "}"
            tex.println "\\begin{document}"
            inputs.files.each { dir ->
                dir.eachFile { file ->
                    file.eachLine { line ->
                        tex.println "\\prompt{$line}"
                    }
                }
            }
            tex.println "\\end{document}"
        }
    }
}

task compilePromptList(type: Exec) {
    inputs.files generatePromptList
    outputs.files "$buildDir/prompts.pdf"
    executable 'latexmk'
    doFirst {
        args '-pdf', "-output-directory=$temporaryDir", '-quiet', inputs.files.singleFile
    }
    doLast {
        copy {
            from temporaryDir
            into buildDir
            include 'prompts.pdf'
        }
    }
}

task convertTextGridsToJson {
    dependsOn processDataResources
    def textGridFiles = sourceSets.data.resources.asFileTree.include('*.TextGrid').files.collect()
    def jsonFiles = textGridFiles.collect {
        file("$sourceSets.data.output.resourcesDir/$it.name" - 'TextGrid' + 'json')
    }
    def praatScript = 'src/data/praat/TextGrid2JSON.praat'
    inputs.files textGridFiles, praatScript
    outputs.files jsonFiles
    doLast {
        [textGridFiles, jsonFiles].transpose().each { textGridFile, jsonFile ->
            exec {
                commandLine "praat $praatScript $textGridFile $jsonFile".tokenize()
            }
        }
    }
}

task extractAudio {
    inputs.files processDataResources, convertTextGridsToJson

    doLast {
        convertTextGridsToJson.outputs.files.each { jsonFile ->
            def speaker = jsonFile.name - '.json'
            def flacFile = file(jsonFile.path - '.json' + '.flac')
            assert flacFile.exists()
            new JsonSlurper().parse(jsonFile).each { prompt ->
                exec {
                    commandLine "sox $flacFile.path ${speaker}_${prompt.prompt}.wav trim $prompt.start =$prompt.end".tokenize()
                    workingDir sourceSets.data.output.resourcesDir
                }
                file("$sourceSets.data.output.resourcesDir/${speaker}_${prompt.prompt}.txt").text = prompt.text
            }
        }
    }

}
